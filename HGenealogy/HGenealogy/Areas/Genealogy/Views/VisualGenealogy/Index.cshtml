@model  HGenealogy.Models.VisualGeneMetaViewModel

@{
    ViewBag.Title = "視覺化族譜";
}

<h2>視覺化族譜</h2>


<div class="row">
    <div class="col-md-2">

        <p>
            @Html.Label("請選擇要查看的族譜:"): @Html.DropDownList("GeneMeta", (IEnumerable<SelectListItem>)ViewBag.geneMetaSelectList, "", new { id = "GeneMeta" })
        </p>
        <p>
            @Html.Label("請選擇家族成員:"): @Html.DropDownList("Families", (IEnumerable<SelectListItem>)ViewBag.familyPersonSelectList, "", new { id = "Families" })
        </p>

        <div>
            <table class="table">
                <tr>
                    <th>
                        世代
                    </th>
                    <th>
                        名字
                    </th>
                    <th>
                        住址
                    </th>
                    <th></th>
                </tr>
                <tbody id="familytreelist"></tbody>
            </table>
        </div>
    </div>

    <div class="col-md-4">
        <div>
            <p>
                <a id="viewDistribution" class="btn btn-default" href="#">分佈圖</a>
                <a id="viewMap" class="btn btn-default" href="#">遷徒圖</a>
            </p>
            <p>
                <a id="viewDistributionNew" class="btn btn-default" href="#">分佈圖2</a>
                <a id="viewMapNew" class="btn btn-default" href="#">遷徒圖2</a>
            </p>


        </div>

        <div id="map" style="width: 800px; height: 600px"></div>

    </div>
</div>

<script src="/Scripts/Map/leaflet/leaflet-src.js"></script>
<script src="/Scripts/Map/AnimatedMarker.js"></script>
<script src="/Scripts/Map/raphael/raphael-src.js"></script>
<script src="/Scripts/Map/raphael/rlayer-src.js"></script>
<script src="/Scripts/Map/raphael/adelaide.js"></script>
<script src="/Scripts/project.visualgenealogy.js"></script>
<script src="/Scripts/Map/leaflet/L.LineUtil.PolylineDecorator.js"></script>
<script src="/Scripts/Map/leaflet/L.RotatedMarker.js"></script>
<script src="/Scripts/Map/leaflet/L.Symbol.js"></script>
<script src="/Scripts/Map/leaflet/L.PolylineDecorator.js"></script>

<script>
    function GetNameWordLinkString(name) {
        var returnstr = "";
        //for (var i = 0; i < name.length; i++) {
            returnstr += name + "<a href=\"https://www.moedict.tw/:" + name + "\">客語讀音</a>";
        //}

        return returnstr;
    }

    var displayRoute = 1;
    var points = [];
    var families;
    var familyChain;
    var geojson;
    var map = new L.Map('map');
    resetMap(new L.LatLng(22.989, 115.752), map);

    var info = L.control();
    info.onAdd = function (map) {
        this._div = L.DomUtil.create('div', 'info');
        this.update();
        return this._div;
    };

    info.update = function (props) {
        var genNoStr = '';
        var birthyearStr = '';
        if (props) {
            genNoStr = '第' + props.generation + '代 - <b>' + GetNameWordLinkString(props.name) + '</b><br/>';
            if (props.year) {
                birthyearStr = '生年:' + props.year + '<br/>';
            }
        }

        this._div.innerHTML = (displayRoute === 1 ? '<h4>新竹張姓客家族譜人員遷移圖</h4>' : '<h4>新竹張姓客家族譜人員分佈圖</h4>') +
            (props ? genNoStr + birthyearStr + '居地:' + props.addr : '移到分佈點以查看說明');
    };
    info.addTo(map);

    var legend = L.control({ position: 'bottomright' });
    legend.onAdd = function (map) {

        var div = L.DomUtil.create('div', 'info legend'),
            //years = [1700, 1750, 1800, 1850, 1900, 1950, 2000],
            list = [11, 12, 13, 14, 15, 16],
            labels = [];

        div.innerHTML += '世代別<br>';
        // loop through our density intervals and generate a label with a colored square for each interval
        for (var i = 0; i < list.length; i++) {
            div.innerHTML +=
                '<i style="background:' + getColorByGeneration(list[i]) + '"></i> ' +
                list[i] + '<br>';
            //+ (list[i + 1] ? '&ndash;' + list[i + 1] + '<br>' : '+');
        }

        return div;
    };
    legend.addTo(map);

    $(document).ready(function () {
        $('#GeneMeta').change(function () { ChangeGeneMeta(); });
        $('#Families').change(function () { ChangeFamily(); });
        $('#viewMap').click(function () {
            displayRoute = 1;                        
            showRouteMap(points,map,true);
        });
        $('#viewDistribution').click(function () {
            displayRoute = 0;
            showRouteMap(points, map, false);
        });
        $('#viewMapNew').click(function () {
            displayRoute = 1;
            showPointNew();
            showRouteMapNew();
        });
        $('#viewDistributionNew').click(function () {
            displayRoute = 0;
            showPointNew();
        });

    });

   

    function ChangeGeneMeta() {
        var selectedValue = $('#GeneMeta option:selected').val();
        if ($.trim(selectedValue).length > 0) {
            GetFamilies(selectedValue);
        }
    }

    function GetFamilies(geneMetaID) {
        $.ajax({
            url: '@(Url.Action("GetFamiliesJson", "VisualGenealogy"))',
            data: { geneMetaId: geneMetaID },
            type: 'post',
            cache: false,
            async: false,
            dataType: 'json',
            success: function (data) {
                $('#Families').empty();
                $('#familytreelist').empty();
                if (data.length > 0) {
                    $('#Families').append($('<option></option>').val('').text(''));
                    $.each(data, function (i, item) {
                        if (item.GenerationNo == "0")
                            $('#Families').append($('<option></option>').val(item.Id).text(""));
                        else
                            $('#Families').append($('<option></option>').val(item.Id).text(item.GenerationNo + "世 - " + item.FName));
                    });
                }
            }
        });
    }

    function ChangeFamily() {
        var selectedValue = $('#Families option:selected').val();
        if ($.trim(selectedValue).length > 0) {
            GetFamilyTree(selectedValue);
        }
    }

    function GetFamilyTree(fId) {
        var url = '@(Url.Action("GetFamilyTreeListJson","Families",null, Request.Url.Scheme))';
        var geneID = $('#GeneMeta option:selected').val();
        $.post(url, { geneID: geneID, id: fId }, function (data) {
            points = [];
            families = data.Key;
            familyChain = data.Value;
            $('#familytreelist').empty();
            $.each(data.Key, function (i, item) {
                if (item.AddressLatitude != null && item.AddressLongitude != null) {
                    var newpoint = new L.LatLng(item.AddressLatitude, item.AddressLongitude);
                    points.push(newpoint);
                }

                var address = "";
                if (item.Address)
                { address = item.Address; }

                $('#familytreelist').append('<tr><td>' + item.GenerationNo + "世" + '</td><td>' + item.FName + '</td><td>' + address + '</td></tr>');
            });
            // showAnimatedLine();
        });
    }

    function resetMap1(initialPoint, map) {
        //map.eachLayer(function (layer) {
        //    map.removeLayer(layer);
        //});

        var tiles = new L.TileLayer('http://tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '',
            maxZoom: 18
        });

        //var adelaide = new L.LatLng(22.989, 115.752);
        //var startPoint;

        map.setView(initialPoint, 8).addLayer(tiles);
        //var m = new R.Marker(initialPoint);
        //map.addLayer(m);
    }

    function test(map) {
        resetMap(new L.LatLng(40.68510, -73.94136), map)
        var line = L.polyline([[40.68510, -73.94136], [40.68576, -73.94149], [40.68649, -73.94165]]),
             animatedMarker = L.animatedMarker(line.getLatLngs());

        var animatedMarker = L.animatedMarker(line.getLatLngs(), {
            distance: 300,  // meters
            interval: 2000, // milliseconds
        });

        map.addLayer(animatedMarker);

        var myIcon = L.icon({
            iconUrl: 'myicon.png'
        });

        var animatedMarker = L.animatedMarker(line.getLatLngs(), {
            icon: myIcon
        });

        // Start when you're ready
        animatedMarker.start();

        setTimeout(function () {
            // Stop the animation
            animatedMarker.stop();
        }, 2000);

    }

    //function showAnimatedLine() {
    //    if (points && points.length > 0) {
    //        resetMap(points[0], map);
    //        points.forEach(function (p) {
    //            showPoint(p);
    //        });
    //        var routeLine = L.polyline(points, { color: 'red' }).addTo(map);
    //        // zoom the map to the polyline
    //        map.fitBounds(routeLine.getBounds());
    //    }
    //}
    //function showPoint(currentPoint) {
    //    if (!currentPoint) {
    //        return;
    //    }

    //    var p = new R.Pulse(
    //            currentPoint,
    //            6,
    //            { 'stroke': '#FF2626', 'fill': '#FF2626' },
    //            { 'stroke': '#FF2626', 'stroke-width': 4 });

    //    map.addLayer(p);
    //    setTimeout(function () {
    //        //map.removeLayer(b).removeLayer(p);
    //    }, 3000);
    //}
    //function showRouteMap() {

    //    var currentPoint;
    //    var attr = {
    //        'stroke': '#B35900',
    //        'stroke-width': 3
    //    };

    //    if (points) {
    //        for (i = 0; i < points.length; i++) {
    //            currentPoint = points[i];
    //            if (i == 0) {
    //                resetMap(currentPoint, map);
    //            }
    //            showPoint(currentPoint);
    //            if (i >= 1 && displayRoute) {
    //                startPoint = points[i - 1];
    //                var b = new R.BezierAnim([startPoint, currentPoint], attr, showPoint);
    //                map.addLayer(b);
    //            }
    //        }
    //    }
    //}
    function showPointNew() {
        var geoData = '';
        var geoDataTemp = '';
        var prefix = '{"type": "Feature", "geometry": {"type": "Point", "coordinates":';

        resetMap(new L.LatLng(22.989, 115.752), map);
        var i = 0;
        if (families && families.length > 0) {
            for (var f in families) {
                var p = families[f];
                if (!(p.AddressLongitude && p.AddressLatitude))
                    continue;

                if (i == 0) {
                    resetMap(new L.LatLng(p.AddressLatitude, p.AddressLongitude), map);
                }
                i++;

                var js1 = { "name": p.FName, "addr": p.Address, "generation": p.GenerationNo, "year": p.BirthYear };
                geoDataTemp = prefix + '[' + p.AddressLongitude + ',' + p.AddressLatitude + ']}, "properties": ' + JSON.stringify(js1) + '}';
                geoData = (geoData === '' ? '' : geoData + ',') + geoDataTemp;
            }
        }
        geoData = '{"type": "FeatureCollection", "features":[' + geoData + ']}';
        var geoDataObj = JSON.parse(geoData);
        geojson = L.geoJson(geoDataObj, {
            style: style,
            pointToLayer: function (feature, latlng) {
                return L.circleMarker(latlng, geojsonMarkerOptions);
            },
            onEachFeature: onEachFeature
        }).addTo(map);


    }
    function resetHighlight(e) {
        geojson.resetStyle(e.target);
        // info.update();
    }
    function showRouteMapNew() {

        //resetMap(new L.LatLng(24.73302040, 121.08981030), map);
        var markedPoint = [];

        // --- Arrow, with animation to demonstrate the use of setPatterns ---
        //var arrow = L.polyline([[24.73302040, 121.08981030], [24.974377, 121.227383]], {}).addTo(map);
        //var arrowHead = L.polylineDecorator(arrow).addTo(map);

        //var arrowOffset = 0;
        //var anim = window.setInterval(function () {
        //    arrowHead.setPatterns([
        //        { offset: arrowOffset + '%', repeat: 0, symbol: L.Symbol.arrowHead({ pixelSize: 15, polygon: false, pathOptions: { stroke: true } }) }
        //    ])
        //    if (++arrowOffset > 100)
        //        arrowOffset = 0;
        //}, 100);

        if (familyChain && familyChain.length > 0) {
            for (var chainindex in familyChain) {

                var multiPointJsonStr = '';
                var chain = familyChain[chainindex];
                var lastpoint;

                if (1==2 && chain.length == 2 && chain[0].AddressLatitude && chain[0].AddressLongitude && chain[1].AddressLatitude && chain[1].AddressLongitude) {

                    // 兩點則顯示可移的箭頭
                    var twopointJsonStr = '[[' + chain[0].AddressLatitude + ',' + chain[0].AddressLongitude + '], [' + chain[0].AddressLatitude + ',' + chain[0].AddressLongitude + ']]';
                    //var arrow = L.polyline([[24.73302040, 121.08981030], [24.974377, 121.227383]], {}).addTo(map);
                    var arrow = L.polyline(twopointJsonStr, {}).addTo(map);
                    var arrowHead = L.polylineDecorator(arrow).addTo(map);

                    var arrowOffset = 0;
                    var anim = window.setInterval(function () {
                        arrowHead.setPatterns([
                            { offset: arrowOffset + '%', repeat: 0, symbol: L.Symbol.arrowHead({ pixelSize: 15, polygon: false, pathOptions: { stroke: true } }) }
                        ])
                        if (++arrowOffset > 100)
                            arrowOffset = 0;
                    }, 100);
                }
                else {
                    for (findex = (chain.length - 1) ; findex >= 0; findex--) {
                        if (chain[findex].AddressLatitude && chain[findex].AddressLongitude) {
                            if ((!lastpoint || findex == (chain.length - 1)) || (lastpoint && ([findex].AddressLatitude != lastpoint.lat || chain[findex].AddressLongitude != lastpoint.lng))) {
                                multiPointJsonStr = (multiPointJsonStr === '' ? '[' : multiPointJsonStr + ',[') + chain[findex].AddressLatitude + ',' + chain[findex].AddressLongitude + ']';
                                lastpoint = new L.LatLng(chain[findex].AddressLatitude, chain[findex].AddressLongitude);
                            }
                        }
                    }
                    if (multiPointJsonStr == '')
                        continue;

                    multiPointJsonStr = '[[' + multiPointJsonStr + ']]';
                    var multiCoords1 = JSON.parse(multiPointJsonStr);

                    if (multiCoords1 && multiCoords1.length > 0 && multiCoords1[0].length > 1) {
                        var plArray = [];
                        for (var i = 0; i < multiCoords1.length; i++) {
                            plArray.push(L.polyline(multiCoords1[i]).addTo(map));
                        }
                        L.polylineDecorator(multiCoords1, {
                            patterns: [
                                { offset: 25, repeat: 50, symbol: L.Symbol.arrowHead({ pixelSize: 15, pathOptions: { fillOpacity: 1, weight: 0 } }) }
                            ]
                        }).addTo(map);
                    }
                }
            }
        }
        return;

        if (families && families.length > 0) {
            for (i = families.length - 1; i >= 0; i--) {
                var p = families[i];
                var pf;

                if (markedPoint.indexOf(p) >= 0)
                    continue;

                while (true) {
                    if (p && p.FatherId) {
                        //markedPoint.push(p);
                        var result = Enumerable.from(families)
                        .where(function (x) { return x.Id == p.FatherId })
                        .toArray();

                        if (result && result.length > 0) {
                            // draw a line from pf to p
                            pf = result[0];

                            // 無地理座標
                            if (!(p.AddressLatitude && p.AddressLongitude && pf.AddressLatitude && pf.AddressLongitude)) {
                                // shift the fatherid to 有座標的上一代
                                p.FatherId = pf.FatherId;
                                markedPoint.push(p);
                                continue;
                            }

                            // 同點不處理
                            if (pf.AddressLatitude == p.AddressLatitude && pf.AddressLongitude == p.AddressLongitude) {
                                markedPoint.push(p);
                                p = pf;
                                continue;
                            }

                            var arrow = L.polyline([[pf.AddressLatitude, pf.AddressLongitude], [p.AddressLatitude, p.AddressLongitude]], {}).addTo(map);
                            var arrowHead = L.polylineDecorator(arrow).addTo(map);
                            var arrowOffset = 0;
                            var anim = window.setInterval(function () {
                                arrowHead.setPatterns([
                                    { offset: arrowOffset + '%', repeat: 1, symbol: L.Symbol.arrowHead({ pixelSize: 15, polygon: false, pathOptions: { stroke: true } }) }
                                ])
                                if (++arrowOffset > 100)
                                    arrowOffset = 0;
                            }, 100);


                            markedPoint.push(p);
                            p = pf;
                            continue;
                        }

                    } else {
                        break;
                    }
                }
            }
        }
    }

    @*(function () {

        //var events = @Html.Raw(Json.Encode(Model));
        //if(events && events.families)
        //{
        //    for (i = 0; i < events.families.length; i++)
        //    {
        //        if(events.families[i].AddressLatitude != null && events.families[i].AddressLongitude != null){
        //            points.push(new L.LatLng(events.families[i].AddressLatitude, events.families[i].AddressLongitude));
        //        }
        //    }
        //}
        map.on('click', function (e) {
            var currentPoint;
            var attr = {
                'stroke': '#B35900',
                'stroke-width': 3
            };
            if (points) {
                for (i = 0; i < points.length; i++) {
                    currentPoint = points[i];
                    showPoint(currentPoint);

                    if (i >= 1 && displayRoute) {
                        startPoint = points[i - 1];
                        var b = new R.BezierAnim([startPoint, currentPoint], attr, showPoint);
                        map.addLayer(b);
                    }
                }
            }


        });
    }
    )();*@
</script>


